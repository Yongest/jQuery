# 预解析
- 可以理解为js解析引擎在逐行执行代码前，对一些特殊代码的预先执行。
- 也可以认识是在马拉松之前的热身运动。
- 具体一点讲，是js在逐行执行代码前，会对js脚本进行一个整体检查。
    + 1、检测语法有没有错误
    + 2、变量声明提升：检测到变量声明那就率先进行声明(实际上是开辟一个内存空间，将来备用)
    + 3、函数声明提升：检测到函数声明也率先进行声明(实际上是开辟两个内存空间，一个是变量，一个是函数)
- 预解析造成js一个特殊的象限，就是在变量声明和函数声明之前的代码，可以访问它们。
- js预解析完毕之后，才会整体正式逐行执行，但是预解析过的变量声明和函数声明不会重复执行。
- js预解析分为两种，全局预解析(全局代码执行的时候会先预解析)与局部预解析(函数在调用的时候内部的代码会先预解析)

## 变量声明
- 使用通过var定义的变量，才属于变量声明
    + 例如：var a; 属于变量声明。
    + 例如：b = 10; 不属于变量声明。
- var关键字可以通过逗号连续声明多个变量
    + 例如：var a, b, c = 20, d = 30; 
    + a,b,c,d全部属于声明。
- var关键字在声明变量的时候，可以给其赋值，如果赋值表达式中含有一些变量，这些变量不属于变量声明。
    + 例如：var a = b = 10; 
    + 其中a属于变量声明，b不属于。
    
## 函数的定义方式
- 字面量
   - 函数声明
       + function fn(){}
   - 函数表达式
       + var fn = function(){}
- 构造函数
   + new Function()

## 函数声明
> 在js中，函数声明式写法比较单一，好区分。
- 一定是以function关键字开头定义的函数
- 一定具有函数名
- 函数声明有两种，1种是全局函数声明，1中是局部函数声明
    + 函数声明要么在全局，要么直接嵌套在另一个函数内
    
## 函数表达式
> 在js中，函数表达式的编写形式，多种多样。
比如把函数当作数据赋值给变量，或者把函数作为返回值return，或者当做参数传递，或者运算符运算，或者自调函数。
- 要么不是以function关键字开头来定义的函数，要么该函数定义在了语句当中
- 函数名可有可无

## 预解析细节规则
- 变量声明重名 -- 后面的忽略，没有必要定义重复的变量
- 函数声明重名 -- 保留后面的，因为函数体可能不一样，后面的优先与前面的
- 变量与函数重名 -- 保留函数
- 写在代码块中的函数，名字会被预解析，函数体不会
    + 最终造成的现象是，在该函数定义的访问它，不会报错，得到一个undefined
```javascript
console.log(fn)  // undefined
if(true) {
	function fn(){}
}
console.log(fn)  // 函数体
```
- 函数表达式不会被预解析，但是函数表达式定义的函数执行时，其内部会对自己进行函数声明。
    + 最终造成的现象是，在该函数的外面无法通过其名称找到它，但是在内部可以。
```javascript
console.log(fn);  // 报错
var a = function fn(){
	console.log(fn);  // 函数体，因为表达式定义的函数，会在自己内部被声明一次。
}
console.log(fn);  // 报错
```

## 函数执行时形参的赋值
- 一个函数在执行时，会优先定义形参，然后赋值。
- 预解析和逐行执行都慢与形参。
```javascript
(function(a) {
	console.log(a);  // 100
	var a = 200;
	console.log(a);  // 200
}(100));
```

# 闭包
- 有权访问非自身局部变量(非全局变量)的函数，称为闭包。
- 有权访问自由变量(非全局变量)的函数，称为闭包。

## 自由变量
- 一个函数可以访问的非自身内部变量，称为这个函数的自由变量。

## 引用了自由变量的闭包特点
- 会延长自由变量的生命周期，只要闭包不死我就不死

## 闭包的应用
- 可以利用闭包的结构去管理一些重要的变量，防止外界随意对其修改
